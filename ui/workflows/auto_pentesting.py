"""
Auto Pentesting Workflow
Zero-config autonomous pentesting mode
"""

import os
import sys
import json
import time
import yaml
from typing import Dict, Any, Optional
from datetime import datetime

# Add paths for imports
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)
sys.path.insert(0, os.path.join(parent_dir, 'apfa_agent'))

try:
    from ui.components import MenuSystem, ProgressBar, Color, UIComponent
except ImportError:
    sys.path.insert(0, os.path.join(parent_dir, 'ui'))
    from components import MenuSystem, ProgressBar, Color, UIComponent

class AutoPentesting(UIComponent):
    """Zero-config autonomous pentesting workflow"""
    
    def __init__(self):
        super().__init__()
        self.menu_system = MenuSystem()
        self.progress_bar = ProgressBar()
        self.config = {}
        
    def run_auto_pentest(self, config: Optional[Dict[str, Any]] = None) -> bool:
        """Main entry point for auto pentesting"""
        if config:
            self.config = config
            
        try:
            # Step 1: Configuration
            pentest_config = self._configure_pentest()
            if not pentest_config:
                return False
                
            # Step 2: Execute Auto Pentest
            return self._execute_auto_pentest(pentest_config)
            
        except KeyboardInterrupt:
            print(f"\n{Color.YELLOW.value}âš ï¸  Auto pentest interrupted by user{Color.RESET.value}")
            return False
        except Exception as e:
            print(f"{Color.RED.value}âŒ Auto pentest failed: {e}{Color.RESET.value}")
            return False
            
    def _configure_pentest(self) -> Optional[Dict[str, Any]]:
        """Configure auto pentest settings"""
        while True:
            self.clear_screen()
            self.menu_system.show_banner("ðŸ¤– Auto Pentesting Configuration")
            
            # Get target
            default_target = self.config.get('target', {}).get('ip', '127.0.0.1')
            target = input(f"Target IP [{default_target}]: ").strip() or default_target
            
            if not target:
                print(f"{Color.RED.value}âŒ Target IP required{Color.RESET.value}")
                input("Press Enter to continue...")
                continue
                
            # Scan depth
            print(f"\nScan Depth:")
            print("1. Quick Scan (top 1000 ports, fast)")
            print("2. Standard Scan (top 5000 ports, thorough)")
            print("3. Deep Scan (all ports, comprehensive)")
            
            depth_choice = input("Select scan depth (1-3): ").strip()
            depth_map = {
                '1': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                '2': {'name': 'Standard', 'ports': '5000', 'timing': 'T4'},
                '3': {'name': 'Deep', 'ports': '-', 'timing': 'T3'}
            }
            scan_depth = depth_map.get(depth_choice, depth_map['2'])
            
            # Attack level
            print(f"\nAttack Level:")
            print("1. Safe - Information gathering only")
            print("2. Moderate - Safe exploits only")
            print("3. Aggressive - All exploits allowed")
            
            attack_choice = input("Select attack level (1-3): ").strip()
            attack_map = {
                '1': {'name': 'Safe', 'mode': 'safe'},
                '2': {'name': 'Moderate', 'mode': 'moderate'},
                '3': {'name': 'Aggressive', 'mode': 'aggressive'}
            }
            attack_level = attack_map.get(attack_choice, attack_map['2'])
            
            # Time limit
            print(f"\nTime Limit:")
            print("1. 30 minutes")
            print("2. 1 hour")
            print("3. 2 hours")
            print("4. No limit")
            
            time_choice = input("Select time limit (1-4): ").strip()
            time_map = {
                '1': 30, '2': 60, '3': 120, '4': 0
            }
            time_limit = time_map.get(time_choice, 60)
            
            # Show summary
            self.clear_screen()
            print(f"{Color.BOLD}ðŸ¤– Auto Pentest Configuration{Color.RESET}")
            print("=" * 50)
            print(f"Target:        {target}")
            print(f"Scan Depth:    {scan_depth['name']} ({scan_depth['ports']} ports)")
            print(f"Attack Level:  {attack_level['name']} ({attack_level['mode']})")
            print(f"Time Limit:    {'No limit' if time_limit == 0 else f'{time_limit} minutes'}")
            
            # Presets
            print(f"\n{Color.BOLD}âš¡ Quick Presets:{Color.RESET}")
            print("[C] Corporate Network")
            print("[H] Home Lab") 
            print("[T] Testing Environment")
            print("[Q] Quick Test")
            
            choice = input(f"\n[S]tart Pentest | [M]odify | [P]reset | [B]ack: ").strip().lower()
            
            if choice == 's':
                return {
                    'target': target,
                    'scan_depth': scan_depth,
                    'attack_level': attack_level,
                    'time_limit': time_limit
                }
            elif choice == 'c':
                return self._apply_preset('corporate', target)
            elif choice == 'h':
                return self._apply_preset('home_lab', target)
            elif choice == 't':
                return self._apply_preset('testing', target)
            elif choice == 'q':
                return self._apply_preset('quick', target)
            elif choice == 'b':
                return None
                
    def _apply_preset(self, preset: str, target: str) -> Dict[str, Any]:
        """Apply configuration preset"""
        presets = {
            'corporate': {
                'scan_depth': {'name': 'Standard', 'ports': '5000', 'timing': 'T4'},
                'attack_level': {'name': 'Safe', 'mode': 'safe'},
                'time_limit': 120
            },
            'home_lab': {
                'scan_depth': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                'attack_level': {'name': 'Moderate', 'mode': 'moderate'},
                'time_limit': 60
            },
            'testing': {
                'scan_depth': {'name': 'Deep', 'ports': '-', 'timing': 'T3'},
                'attack_level': {'name': 'Aggressive', 'mode': 'aggressive'},
                'time_limit': 0
            },
            'quick': {
                'scan_depth': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                'attack_level': {'name': 'Safe', 'mode': 'safe'},
                'time_limit': 30
            }
        }
        
        preset_config = presets.get(preset, presets['quick'])
        preset_config['target'] = target
        
        return preset_config
        
    def _execute_auto_pentest(self, pentest_config: Dict[str, Any]) -> bool:
        """Execute the auto pentest"""
        self.clear_screen()
        print(f"{Color.BOLD}ðŸ¤– Auto Pentesting in Progress...{Color.RESET}")
        print("=" * 60)
        
        target = pentest_config['target']
        scan_depth = pentest_config['scan_depth']
        attack_level = pentest_config['attack_level']
        time_limit = pentest_config['time_limit']
        
        print(f"Target: {target}")
        print(f"Scan: {scan_depth['name']} | Attack: {attack_level['name']}")
        print(f"Time Limit: {'No limit' if time_limit == 0 else f'{time_limit} minutes'}")
        
        print(f"\n{Color.CYAN.value}ðŸ”„ Starting autonomous pentesting workflow...{Color.RESET.value}")
        
        # Phase 1: Discovery
        success = self._phase_discovery(target, scan_depth)
        if not success:
            return False
            
        # Phase 2: Vulnerability Assessment
        success = self._phase_vulnerability_assessment(target)
        if not success:
            return False
            
        # Phase 3: Exploitation
        success = self._phase_exploitation(target, attack_level, time_limit)
        if not success:
            return False
            
        # Phase 4: Reporting
        self._phase_reporting(target)
        
        return True
        
    def _phase_discovery(self, target: str, scan_depth: Dict[str, Any]) -> bool:
        """Phase 1: Network Discovery"""
        print(f"\n{Color.BOLD}ðŸ“¡ Phase 1: Network Discovery{Color.RESET}")
        print("-" * 40)
        
        try:
            from apfa_agent.core.nmap_scanner import NmapScanner
            
            # Build nmap arguments
            if scan_depth['ports'] == '-':
                port_arg = "-p-"
            else:
                port_arg = f"--top-ports {scan_depth['ports']}"
                
            nmap_args = f"-sV -sC {port_arg} {scan_depth['timing']}"
            
            print(f"Scanning {target} with: {nmap_args}")
            
            # Execute scan
            scanner = NmapScanner(self.config)
            results = scanner.scan(target)
            
            print(f"{Color.GREEN.value}âœ… Discovery completed{Color.RESET.value}")
            
            # Save results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            scan_file = f"auto_scan_{target}_{timestamp}.json"
            scan_path = os.path.join(os.path.dirname(__file__), '../../data/scans', scan_file)
            
            os.makedirs(os.path.dirname(scan_path), exist_ok=True)
            
            with open(scan_path, 'w') as f:
                json.dump({
                    'target': target,
                    'timestamp': timestamp,
                    'scan_type': 'auto_discovery',
                    'results': results
                }, f, indent=2)
                
            print(f"Results saved to: {scan_file}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Discovery failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_vulnerability_assessment(self, target: str) -> bool:
        """Phase 2: Vulnerability Assessment"""
        print(f"\n{Color.BOLD}ðŸ” Phase 2: Vulnerability Assessment{Color.RESET}")
        print("-" * 40)
        
        try:
            from classifier.vulnerability_classifier import VulnerabilityClassifier
            from parser.nessus_to_llm import VulnProcessor
            
            print("Analyzing scan results for vulnerabilities...")
            
            # For auto mode, we'll create synthetic vulnerabilities from scan results
            # In a real implementation, this would integrate with vulnerability scanners
            vulnerabilities = self._generate_vulnerabilities_from_scan(target)
            
            if not vulnerabilities:
                print(f"{Color.YELLOW.value}âš ï¸  No vulnerabilities detected{Color.RESET.value}")
                return True
                
            print(f"Found {len(vulnerabilities)} potential vulnerabilities")
            
            # Classify vulnerabilities
            print("Classifying and enriching vulnerability data...")
            classifier = VulnerabilityClassifier(enable_rag=False)
            classified_results = classifier.classify_batch(vulnerabilities)
            
            print(f"{Color.GREEN.value}âœ… Vulnerability assessment completed{Color.RESET.value}")
            
            # Save classified results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            vuln_file = f"auto_vulns_{target}_{timestamp}.json"
            vuln_path = os.path.join(os.path.dirname(__file__), '../../data/temp', vuln_file)
            
            os.makedirs(os.path.dirname(vuln_path), exist_ok=True)
            
            with open(vuln_path, 'w') as f:
                json.dump({
                    'target': target,
                    'timestamp': timestamp,
                    'assessment_type': 'auto_vulnerability',
                    'vulnerabilities': classified_results
                }, f, indent=2)
                
            print(f"Vulnerability data saved to: {vuln_file}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Vulnerability assessment failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_exploitation(self, target: str, attack_level: Dict[str, Any], time_limit: int) -> bool:
        """Phase 3: Exploitation"""
        print(f"\n{Color.BOLD}ðŸŽ¯ Phase 3: Exploitation ({attack_level['name']}){Color.RESET}")
        print("-" * 40)
        
        try:
            from apfa_agent.agent_mode import SmartTriageAgent
            
            print("Launching intelligent exploitation agent...")
            
            # Configure agent based on attack level
            agent_config = self.config.copy()
            if 'execution' not in agent_config:
                agent_config['execution'] = {}
            agent_config['execution']['mode'] = attack_level['mode']
            
            if time_limit > 0:
                agent_config['execution']['timeout'] = time_limit * 60  # Convert to seconds
                
            # Create and run agent
            agent = SmartTriageAgent(config_path=self._get_config_path(), config=agent_config)
            
            # Find the most recent vulnerability assessment
            vuln_path = self._find_latest_vulnerability_file(target)
            
            if vuln_path:
                print(f"Using vulnerability data: {vuln_path}")
                agent.run(classified_json_path=vuln_path, nmap_results=None)
            else:
                print("Running agent without prior vulnerability data...")
                agent.run(classified_json_path=None, nmap_results=None)
                
            print(f"{Color.GREEN.value}âœ… Exploitation phase completed{Color.RESET.value}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Exploitation failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_reporting(self, target: str):
        """Phase 4: Reporting"""
        print(f"\n{Color.BOLD}ðŸ“‹ Phase 4: Report Generation{Color.RESET}")
        print("-" * 40)
        
        try:
            from apfa_agent.report_generator import ReportGenerator
            
            print("Generating comprehensive pentest report...")
            
            # Generate report
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = f"auto_pentest_report_{target}_{timestamp}.json"
            report_path = os.path.join(os.path.dirname(__file__), '../../data/agent_results', report_file)
            
            os.makedirs(os.path.dirname(report_path), exist_ok=True)
            
            # Create summary report
            report = {
                'target': target,
                'timestamp': timestamp,
                'pentest_type': 'auto_pentest',
                'phases_completed': ['discovery', 'vulnerability_assessment', 'exploitation'],
                'summary': {
                    'status': 'completed',
                    'duration': 'Auto-generated',
                    'findings': 'See agent results for details'
                },
                'files_generated': [
                    'scan_results.json',
                    'vulnerability_assessment.json',
                    'agent_execution_results.json'
                ]
            }
            
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)
                
            print(f"{Color.GREEN.value}âœ… Report generated: {report_file}{Color.RESET.value}")
            print(f"\n{Color.BOLD}ðŸ“Š Auto Pentest Summary{Color.RESET}")
            print("=" * 40)
            print(f"Target: {target}")
            print(f"Status: Completed successfully")
            print(f"Results: data/agent_results/")
            print(f"Report: {report_file}")
            
        except Exception as e:
            print(f"{Color.YELLOW.value}âš ï¸  Report generation failed: {e}{Color.RESET.value}")
            print("Raw results are still available in data/agent_results/")
            
    def _generate_vulnerabilities_from_scan(self, target: str) -> list:
        """Generate synthetic vulnerabilities from scan results"""
        # This is a simplified version - in practice, this would
        # integrate with actual vulnerability scanners
        
        vulnerabilities = []
        
        # Add some common service-based vulnerabilities for demonstration
        common_services = [
            {'port': 22, 'service': 'ssh', 'vuln': 'SSH Weak Configuration'},
            {'port': 80, 'service': 'http', 'vuln': 'HTTP Information Disclosure'},
            {'port': 443, 'service': 'https', 'vuln': 'SSL/TLS Configuration'},
            {'port': 21, 'service': 'ftp', 'vuln': 'FTP Anonymous Access'},
            {'port': 23, 'service': 'telnet', 'vuln': 'Telnet Unencrypted'},
        ]
        
        for i, service_info in enumerate(common_services):
            vuln = {
                'id': f'auto_vuln_{target}_{service_info["port"]}_{i}',
                'h': target,
                'p': service_info['port'],
                's': 2,  # Medium severity
                'pn': service_info['vuln'],
                'c': '',
                'cvss': 5.0,
                'd': f'Potential {service_info["vuln"]} on {service_info["service"]} service',
                'sol': 'Review and harden service configuration'
            }
            vulnerabilities.append(vuln)
            
        return vulnerabilities
        
    def _find_latest_vulnerability_file(self, target: str) -> Optional[str]:
        """Find the most recent vulnerability assessment file"""
        temp_dir = os.path.join(os.path.dirname(__file__), '../../data/temp')
        
        if not os.path.exists(temp_dir):
            return None
            
        files = []
        for f in os.listdir(temp_dir):
            if f.startswith(f'auto_vulns_{target}') and f.endswith('.json'):
                file_path = os.path.join(temp_dir, f)
                files.append((os.path.getmtime(file_path), file_path))
                
        if files:
            # Return the most recent file
            files.sort(reverse=True)
            return files[0][1]
            
        return None
        
    def _get_config_path(self) -> str:
        """Get path to agent configuration"""
        return os.path.join(os.path.dirname(__file__), '../../apfa_agent/config/agent_config.yaml')