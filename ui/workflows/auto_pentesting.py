"""
Auto Pentesting Workflow
Zero-config autonomous pentesting mode
"""

import os
import sys
import json
import time
import yaml
from typing import Dict, Any, Optional
from datetime import datetime

# Add paths for imports
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)
sys.path.insert(0, os.path.join(parent_dir, 'apfa_agent'))

try:
    from ui.components import MenuSystem, ProgressBar, Color, UIComponent
except ImportError:
    sys.path.insert(0, os.path.join(parent_dir, 'ui'))
    from components import MenuSystem, ProgressBar, Color, UIComponent

# Import connectivity checking
sys.path.insert(0, os.path.join(parent_dir, 'apfa_agent'))
from utils.connectivity import check_host_connectivity

class AutoPentesting(UIComponent):
    """Zero-config autonomous pentesting workflow"""
    
    def __init__(self):
        super().__init__()
        self.menu_system = MenuSystem()
        self.progress_bar = ProgressBar()
        self.config = {}
        
    def run_auto_pentest(self, config: Optional[Dict[str, Any]] = None) -> bool:
        """Main entry point for auto pentesting"""
        if config:
            self.config = config
            
        try:
            # Step 1: Configuration
            pentest_config = self._configure_pentest()
            if not pentest_config:
                return False
                
            # Step 2: Execute Auto Pentest
            return self._execute_auto_pentest(pentest_config)
            
        except KeyboardInterrupt:
            print(f"\n{Color.YELLOW.value}âš ï¸  Auto pentest interrupted by user{Color.RESET.value}")
            return False
        except Exception as e:
            print(f"{Color.RED.value}âŒ Auto pentest failed: {e}{Color.RESET.value}")
            return False
            
    def _configure_pentest(self) -> Optional[Dict[str, Any]]:
        """Configure auto pentest settings"""
        while True:
            self.clear_screen()
            self.menu_system.show_banner("ðŸ¤– Auto Pentesting Configuration")
            
            # Get target
            default_target = self.config.get('target', {}).get('ip', '127.0.0.1')
            target = input(f"Target IP [{default_target}]: ").strip() or default_target
            
            if not target:
                print(f"{Color.RED.value}âŒ Target IP required{Color.RESET.value}")
                input("Press Enter to continue...")
                continue
                
            # Scan depth
            print(f"\nScan Depth:")
            print("1. Quick Scan (top 1000 ports, fast)")
            print("2. Standard Scan (top 5000 ports, thorough)")
            print("3. Deep Scan (all ports, comprehensive)")
            
            depth_choice = input("Select scan depth (1-3): ").strip()
            depth_map = {
                '1': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                '2': {'name': 'Standard', 'ports': '5000', 'timing': 'T4'},
                '3': {'name': 'Deep', 'ports': '-', 'timing': 'T3'}
            }
            scan_depth = depth_map.get(depth_choice, depth_map['2'])
            
            # Attack level
            print(f"\nAttack Level:")
            print("1. Safe - Information gathering only")
            print("2. Moderate - Safe exploits only")
            print("3. Aggressive - All exploits allowed")
            
            attack_choice = input("Select attack level (1-3): ").strip()
            attack_map = {
                '1': {'name': 'Safe', 'mode': 'safe'},
                '2': {'name': 'Moderate', 'mode': 'moderate'},
                '3': {'name': 'Aggressive', 'mode': 'aggressive'}
            }
            attack_level = attack_map.get(attack_choice, attack_map['2'])
            
            # Time limit
            print(f"\nTime Limit:")
            print("1. 30 minutes")
            print("2. 1 hour")
            print("3. 2 hours")
            print("4. No limit")
            
            time_choice = input("Select time limit (1-4): ").strip()
            time_map = {
                '1': 30, '2': 60, '3': 120, '4': 0
            }
            time_limit = time_map.get(time_choice, 60)
            
            # Show summary
            self.clear_screen()
            print(f"{Color.BOLD}ðŸ¤– Auto Pentest Configuration{Color.RESET}")
            print("=" * 50)
            print(f"Target:        {target}")
            print(f"Scan Depth:    {scan_depth['name']} ({scan_depth['ports']} ports)")
            print(f"Attack Level:  {attack_level['name']} ({attack_level['mode']})")
            print(f"Time Limit:    {'No limit' if time_limit == 0 else f'{time_limit} minutes'}")
            
            # Presets
            print(f"\n{Color.BOLD}âš¡ Quick Presets:{Color.RESET}")
            print("[C] Corporate Network")
            print("[H] Home Lab") 
            print("[T] Testing Environment")
            print("[Q] Quick Test")
            
            choice = input(f"\n[S]tart Pentest | [M]odify | [P]reset | [B]ack: ").strip().lower()
            
            if choice == 's':
                return {
                    'target': target,
                    'scan_depth': scan_depth,
                    'attack_level': attack_level,
                    'time_limit': time_limit
                }
            elif choice == 'c':
                return self._apply_preset('corporate', target)
            elif choice == 'h':
                return self._apply_preset('home_lab', target)
            elif choice == 't':
                return self._apply_preset('testing', target)
            elif choice == 'q':
                return self._apply_preset('quick', target)
            elif choice == 'b':
                return None
                
    def _apply_preset(self, preset: str, target: str) -> Dict[str, Any]:
        """Apply configuration preset"""
        presets = {
            'corporate': {
                'scan_depth': {'name': 'Standard', 'ports': '5000', 'timing': 'T4'},
                'attack_level': {'name': 'Safe', 'mode': 'safe'},
                'time_limit': 120
            },
            'home_lab': {
                'scan_depth': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                'attack_level': {'name': 'Moderate', 'mode': 'moderate'},
                'time_limit': 60
            },
            'testing': {
                'scan_depth': {'name': 'Deep', 'ports': '-', 'timing': 'T3'},
                'attack_level': {'name': 'Aggressive', 'mode': 'aggressive'},
                'time_limit': 0
            },
            'quick': {
                'scan_depth': {'name': 'Quick', 'ports': '1000', 'timing': 'T4'},
                'attack_level': {'name': 'Safe', 'mode': 'safe'},
                'time_limit': 30
            }
        }
        
        preset_config = presets.get(preset, presets['quick'])
        preset_config['target'] = target
        
        return preset_config
        
    def _execute_auto_pentest(self, pentest_config: Dict[str, Any]) -> bool:
        """Execute the auto pentest"""
        self.clear_screen()
        print(f"{Color.BOLD}ðŸ¤– Auto Pentesting in Progress...{Color.RESET}")
        print("=" * 60)
        
        target = pentest_config['target']
        scan_depth = pentest_config['scan_depth']
        attack_level = pentest_config['attack_level']
        time_limit = pentest_config['time_limit']
        
        print(f"Target: {target}")
        print(f"Scan: {scan_depth['name']} | Attack: {attack_level['name']}")
        print(f"Time Limit: {'No limit' if time_limit == 0 else f'{time_limit} minutes'}")
        
        print(f"\n{Color.CYAN.value}ðŸ”„ Starting autonomous pentesting workflow...{Color.RESET.value}")
        
        # Pre-flight check: Verify target is reachable
        print(f"\n{Color.BOLD}ðŸ” Pre-Flight Check: Verifying Target Connectivity{Color.RESET}")
        print("-" * 40)
        print(f"Checking if {target} is online and reachable...")
        
        try:
            is_reachable, connectivity_msg = check_host_connectivity(target, port=None, timeout=10)
            
            if not is_reachable:
                print(f"{Color.RED.value}âŒ Target {target} is NOT reachable!{Color.RESET.value}")
                print(f"   Reason: {connectivity_msg}")
                print(f"\n{Color.YELLOW.value}âš ï¸  Cannot proceed with pentesting.{Color.RESET.value}")
                print("\nPlease verify:")
                print("  â€¢ Target VM/machine is powered on")
                print("  â€¢ Network connectivity is working")
                print("  â€¢ Correct IP address is configured")
                print("  â€¢ No firewall is blocking all traffic")
                input(f"\nPress Enter to return to menu...")
                return False
            
            print(f"{Color.GREEN.value}âœ… Target {target} is reachable and online{Color.RESET.value}")
            print(f"   {connectivity_msg}")
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Connectivity check failed: {e}{Color.RESET.value}")
            print(f"\n{Color.YELLOW.value}âš ï¸  Warning: Cannot verify target connectivity. Proceeding anyway...{Color.RESET.value}")
            input(f"\nPress Enter to continue or Ctrl+C to abort...")
        
        # Phase 1: Discovery
        success = self._phase_discovery(target, scan_depth)
        if not success:
            return False
            
        # Phase 2: Vulnerability Assessment
        success = self._phase_vulnerability_assessment(target)
        if not success:
            return False
            
        # Phase 3: Exploitation
        success = self._phase_exploitation(target, attack_level, time_limit)
        if not success:
            return False
            
        # Phase 4: Reporting
        self._phase_reporting(target)
        
        return True
        
    def _phase_discovery(self, target: str, scan_depth: Dict[str, Any]) -> bool:
        """Phase 1: Network Discovery"""
        print(f"\n{Color.BOLD}ðŸ“¡ Phase 1: Network Discovery{Color.RESET}")
        print("-" * 40)
        
        # Double-check target connectivity before scanning
        print(f"Verifying {target} is still reachable before scan...")
        try:
            is_reachable, msg = check_host_connectivity(target, port=None, timeout=5)
            if not is_reachable:
                print(f"{Color.RED.value}âŒ Target became unreachable: {msg}{Color.RESET.value}")
                return False
            print(f"âœ“ Target confirmed reachable")
        except Exception as e:
            print(f"{Color.YELLOW.value}âš ï¸  Connectivity check warning: {e}{Color.RESET.value}")
        
        try:
            from apfa_agent.core.nmap_scanner import NmapScanner
            
            # Build nmap arguments
            if scan_depth['ports'] == '-':
                port_arg = "-p-"
            else:
                port_arg = f"--top-ports {scan_depth['ports']}"
                
            nmap_args = f"-sV -sC {port_arg} {scan_depth['timing']}"
            
            print(f"Scanning {target} with: {nmap_args}")
            
            # Execute scan
            scanner = NmapScanner(self.config)
            results = scanner.scan(target)
            
            print(f"{Color.GREEN.value}âœ… Discovery completed{Color.RESET.value}")
            
            # Save results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            scan_file = f"auto_scan_{target}_{timestamp}.json"
            scan_path = os.path.join(os.path.dirname(__file__), '../../data/scans', scan_file)
            
            os.makedirs(os.path.dirname(scan_path), exist_ok=True)
            
            with open(scan_path, 'w') as f:
                json.dump({
                    'target': target,
                    'timestamp': timestamp,
                    'scan_type': 'auto_discovery',
                    'results': results
                }, f, indent=2)
                
            print(f"Results saved to: {scan_file}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Discovery failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_vulnerability_assessment(self, target: str) -> bool:
        """Phase 2: Vulnerability Assessment"""
        print(f"\n{Color.BOLD}ðŸ” Phase 2: Vulnerability Assessment{Color.RESET}")
        print("-" * 40)
        
        try:
            from classifier.vulnerability_classifier import VulnerabilityClassifier
            from parser.nessus_to_llm import VulnProcessor
            
            print("Analyzing scan results for vulnerabilities...")
            
            # For auto mode, we'll create synthetic vulnerabilities from scan results
            # In a real implementation, this would integrate with vulnerability scanners
            vulnerabilities = self._generate_vulnerabilities_from_scan(target)
            
            if not vulnerabilities:
                print(f"{Color.YELLOW.value}âš ï¸  No vulnerabilities detected{Color.RESET.value}")
                return True
                
            print(f"Found {len(vulnerabilities)} potential vulnerabilities")
            
            # Classify vulnerabilities
            print("Classifying and enriching vulnerability data...")
            classifier = VulnerabilityClassifier(enable_rag=False)
            classified_results = classifier.classify_batch(vulnerabilities)
            
            print(f"{Color.GREEN.value}âœ… Vulnerability assessment completed{Color.RESET.value}")
            
            # Save classified results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            vuln_file = f"auto_vulns_{target}_{timestamp}.json"
            vuln_path = os.path.join(os.path.dirname(__file__), '../../data/temp', vuln_file)
            
            os.makedirs(os.path.dirname(vuln_path), exist_ok=True)
            
            with open(vuln_path, 'w') as f:
                json.dump({
                    'target': target,
                    'timestamp': timestamp,
                    'assessment_type': 'auto_vulnerability',
                    'vulnerabilities': classified_results
                }, f, indent=2)
                
            print(f"Vulnerability data saved to: {vuln_file}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Vulnerability assessment failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_exploitation(self, target: str, attack_level: Dict[str, Any], time_limit: int) -> bool:
        """Phase 3: Exploitation"""
        print(f"\n{Color.BOLD}ðŸŽ¯ Phase 3: Exploitation ({attack_level['name']}){Color.RESET}")
        print("-" * 40)
        
        try:
            from apfa_agent.agent_mode import SmartTriageAgent
            
            print("Launching intelligent exploitation agent...")
            
            # Configure agent based on attack level
            agent_config = self.config.copy()
            if 'execution' not in agent_config:
                agent_config['execution'] = {}
            agent_config['execution']['mode'] = attack_level['mode']
            
            if time_limit > 0:
                agent_config['execution']['timeout'] = time_limit * 60  # Convert to seconds
                
            # Create and run agent
            agent = SmartTriageAgent(config_path=self._get_config_path(), config=agent_config)
            
            # Find the most recent vulnerability assessment
            vuln_path = self._find_latest_vulnerability_file(target)
            
            if vuln_path:
                print(f"Using vulnerability data: {vuln_path}")
                agent.run(classified_json_path=vuln_path, nmap_results=None)
            else:
                print("Running agent without prior vulnerability data...")
                agent.run(classified_json_path=None, nmap_results=None)
                
            print(f"{Color.GREEN.value}âœ… Exploitation phase completed{Color.RESET.value}")
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}âŒ Exploitation failed: {e}{Color.RESET.value}")
            return False
            
    def _phase_reporting(self, target: str):
        """Phase 4: Reporting"""
        print(f"\n{Color.BOLD}ðŸ“‹ Phase 4: Report Generation{Color.RESET}")
        print("-" * 40)
        
        try:
            from apfa_agent.report_generator import ReportGenerator
            
            print("Generating comprehensive pentest report...")
            
            # Generate report
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = f"auto_pentest_report_{target}_{timestamp}.json"
            report_path = os.path.join(os.path.dirname(__file__), '../../data/agent_results', report_file)
            
            os.makedirs(os.path.dirname(report_path), exist_ok=True)
            
            # Create summary report
            report = {
                'target': target,
                'timestamp': timestamp,
                'pentest_type': 'auto_pentest',
                'phases_completed': ['discovery', 'vulnerability_assessment', 'exploitation'],
                'summary': {
                    'status': 'completed',
                    'duration': 'Auto-generated',
                    'findings': 'See agent results for details'
                },
                'files_generated': [
                    'scan_results.json',
                    'vulnerability_assessment.json',
                    'agent_execution_results.json'
                ]
            }
            
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)
                
            print(f"{Color.GREEN.value}âœ… Report generated: {report_file}{Color.RESET.value}")
            print(f"\n{Color.BOLD}ðŸ“Š Auto Pentest Summary{Color.RESET}")
            print("=" * 40)
            print(f"Target: {target}")
            print(f"Status: Completed successfully")
            print(f"Results: data/agent_results/")
            print(f"Report: {report_file}")
            
        except Exception as e:
            print(f"{Color.YELLOW.value}âš ï¸  Report generation failed: {e}{Color.RESET.value}")
            print("Raw results are still available in data/agent_results/")
            
    def _generate_vulnerabilities_from_scan(self, target: str) -> list:
        """Generate vulnerabilities from ACTUAL Nmap scan results"""
        vulnerabilities = []
        
        try:
            # Find latest Nmap scan result
            import glob
            import os
            
            # Get absolute path to scans directory
            script_dir = os.path.dirname(os.path.abspath(__file__))
            scans_dir = os.path.join(script_dir, '../../data/scans')
            scan_pattern = os.path.join(scans_dir, f'nmap_{target}_*.xml')
            scan_files = glob.glob(scan_pattern)
            if not scan_files:
                print(f"âš ï¸  No Nmap scan found for {target}")
                return []
                
            # Get the most recent scan file
            latest_scan = max(scan_files, key=os.path.getctime)
            print(f"ðŸ“„ Using scan: {os.path.basename(latest_scan)}")
            
            # Parse Nmap XML to get actual services
            import xml.etree.ElementTree as ET
            tree = ET.parse(latest_scan)
            root = tree.getroot()
            
            # Find all open ports with services
            for port in root.findall('.//port'):
                state = port.find('state')
                if state is None or state.get('state') != 'open':
                    continue
                port_id = port.get('portid')
                if not port_id:
                    continue
                    
                service = port.find('service')
                if service is not None:
                    service_name = service.get('name', 'unknown')
                    service_version = service.get('version', '')
                    service_product = service.get('product', '')
                    
                    # Create vulnerability based on ACTUAL service
                    vuln = self._create_vulnerability_for_service(
                        target, port_id, service_name or 'unknown', service_product or '', service_version or ''
                    )
                    if vuln:
                        vulnerabilities.append(vuln)
            
            print(f"âœ… Found {len(vulnerabilities)} real vulnerabilities from scan")
            
        except Exception as e:
            print(f"âŒ Error parsing scan results: {e}")
            # Fallback to empty list rather than fake vulnerabilities
            return []
            
        return vulnerabilities
    
    def _create_vulnerability_for_service(self, target: str, port: str, service: str, product: str, version: str) -> dict:
        """Create vulnerability entry for actual detected service"""
        
        # Service signature for exploit matching
        service_sig = f"{service} {version}".strip() if version else service
        
        # Map known vulnerable services to exploits (match actual Nmap output)
        vuln_mappings = {
            'ftp 2.3.4': {
                'name': 'VSFTPD 2.3.4 Backdoor',
                'cve': 'CVE-2011-2523',
                'cvss': 9.0,
                'desc': 'VSFTPD 2.3.4 contains a backdoor that allows remote code execution'
            },
            'netbios-ssn 3.0.20-debian': {
                'name': 'Samba 3.0.20 Username Map Script',
                'cve': 'CVE-2007-2447', 
                'cvss': 9.0,
                'desc': 'Samba username map script allows command execution as root'
            },
            'samba 3.0.20': {
                'name': 'Samba 3.0.20 Username Map Script',
                'cve': 'CVE-2007-2447', 
                'cvss': 9.0,
                'desc': 'Samba username map script allows command execution as root'
            },
            'http 1.1': {
                'name': 'Apache Tomcat Manager',
                'cve': 'CVE-2009-3843',
                'cvss': 7.5,
                'desc': 'Tomcat manager authentication bypass may allow code execution'
            },
            'postgresql': {
                'name': 'PostgreSQL Payload Execution',
                'cve': '',
                'cvss': 7.0,
                'desc': 'PostgreSQL may allow execution of arbitrary SQL functions'
            },
            'irc': {
                'name': 'UnrealIRCd Backdoor',
                'cve': 'CVE-2010-2075',
                'cvss': 9.0,
                'desc': 'UnrealIRCd contains malicious backdoor'
            }
        }
        
        # Find matching vulnerability (more precise matching)
        vuln_info = None
        service_sig_lower = service_sig.lower()
        
        for key, info in vuln_mappings.items():
            key_lower = key.lower()
            # Exact match first
            if key_lower == service_sig_lower:
                vuln_info = info
                break
            # Product + version match
            elif key_lower in service_sig_lower and len(key_lower) > 5:
                vuln_info = info
                break
            # Product-only match for versionless services
            elif key_lower.split()[0] in service_sig_lower and not version:
                vuln_info = info
                break
        
        # Default vulnerability for unknown services
        if not vuln_info:
            vuln_info = {
                'name': f'{service.upper()} Service',
                'cve': '',
                'cvss': 5.0,
                'desc': f'Potential vulnerabilities in {service} service on port {port}'
            }
        
        return {
            'id': f'real_vuln_{target}_{port}',
            'h': target,
            'p': int(port),
            's': 2 if vuln_info['cvss'] < 7.0 else 1,  # High severity if CVSS >= 7
            'pn': vuln_info['name'],
            'c': vuln_info['cve'],
            'cvss': vuln_info['cvss'],
            'd': vuln_info['desc'],
            'sol': 'Update service or apply security patches',
            'service': service,
            'version': version,
            'product': product,
            'service_signature': service_sig  # For exploit matching
        }
        
    def _find_latest_vulnerability_file(self, target: str) -> Optional[str]:
        """Find the most recent vulnerability assessment file"""
        temp_dir = os.path.join(os.path.dirname(__file__), '../../data/temp')
        
        if not os.path.exists(temp_dir):
            return None
            
        files = []
        for f in os.listdir(temp_dir):
            if f.startswith(f'auto_vulns_{target}') and f.endswith('.json'):
                file_path = os.path.join(temp_dir, f)
                files.append((os.path.getmtime(file_path), file_path))
                
        if files:
            # Return the most recent file
            files.sort(reverse=True)
            return files[0][1]
            
        return None
        
    def _get_config_path(self) -> str:
        """Get path to agent configuration"""
        return os.path.join(os.path.dirname(__file__), '../../apfa_agent/config/agent_config.yaml')