"""
Enhanced Vulnerability Assessment Workflow
Implements the improved scoped pentest functionality
"""

import os
import sys
import json
import yaml
import time
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime

# Add paths for imports
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)
sys.path.insert(0, os.path.join(parent_dir, 'apfa_agent'))
sys.path.insert(0, os.path.join(parent_dir, 'classifier'))
sys.path.insert(0, os.path.join(parent_dir, 'parser'))

try:
    from ui.components import MenuSystem, SelectionGrid, ProgressBar, Color
    from ui.components import UIComponent
except ImportError:
    # Fallback for direct execution
    import sys
    sys.path.insert(0, os.path.join(parent_dir, 'ui'))
    from components import MenuSystem, SelectionGrid, ProgressBar, Color
    from components import UIComponent

class VulnerabilityAssessment(UIComponent):
    """Enhanced vulnerability assessment workflow"""
    
    def __init__(self):
        super().__init__()
        self.menu_system = MenuSystem()
        self.selection_grid = SelectionGrid()
        self.progress_bar = ProgressBar()
        self.config = {}
        
    def run_assessment(self, config: Optional[Dict[str, Any]] = None) -> bool:
        """Main entry point for vulnerability assessment"""
        if config:
            self.config = config
            
        try:
            # Step 1: Input Selection
            scan_data = self._select_input_source()
            if not scan_data:
                return False
                
            # Step 2: Processing
            vulnerabilities = self._process_scan_data(scan_data)
            if not vulnerabilities:
                return False
                
            # Step 3: Target Selection
            selected_targets = self._select_targets(vulnerabilities)
            if not selected_targets:
                return False
                
            # Step 4: Execute Assessment
            return self._execute_assessment(selected_targets)
            
        except KeyboardInterrupt:
            print(f"\n{Color.YELLOW.value}‚ö†Ô∏è  Assessment interrupted by user{Color.RESET.value}")
            return False
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Assessment failed: {e}{Color.RESET.value}")
            return False
            
    def _select_input_source(self) -> Optional[Dict[str, Any]]:
        """Step 1: Select scan input source"""
        while True:
            self.clear_screen()
            self.menu_system.show_banner("üìÇ Select Scan Source")
            
            # Check for available files
            available_files = self._discover_scan_files()
            
            options = [
                {'icon': '[FILE]', 'title': 'Load Nessus Scan', 'description': 'Import .nessus file'},
                {'icon': '[SCAN]', 'title': 'Run Live Nmap Scan', 'description': 'Perform new network scan'},
                {'icon': '[BROWSE]', 'title': 'Browse Available Files', 'description': f'{len(available_files)} files found'},
                {'icon': '[RECENT]', 'title': 'Recent Files', 'description': 'Quick access to recent scans'},
                {'icon': '[BACK]', 'title': 'Back to Main Menu', 'description': 'Return to main menu'}
            ]
            
            choice = self.menu_system.show_menu("üìÇ Select Scan Source", options, show_back=False)
            
            if choice == 0:  # Load Nessus
                return self._load_nessus_file()
            elif choice == 1:  # Live Nmap
                return self._run_nmap_scan()
            elif choice == 2:  # Browse Files
                return self._browse_files(available_files)
            elif choice == 3:  # Recent Files
                return self._show_recent_files()
            elif choice == 4:  # Back
                return None
                
    def _discover_scan_files(self) -> List[Dict[str, str]]:
        """Discover available scan files"""
        files = []
        
        # Check data/input directory
        input_dir = os.path.join(os.path.dirname(__file__), '../data/input')
        if os.path.exists(input_dir):
            for f in os.listdir(input_dir):
                if f.endswith(('.nessus', '.xml', '.json')) and not f.endswith('Zone.Identifier'):
                    files.append({
                        'name': f,
                        'path': os.path.join(input_dir, f),
                        'type': 'nessus' if f.endswith('.nessus') else 'nmap' if f.endswith('.xml') else 'json'
                    })
                    
        # Check data/scans directory
        scans_dir = os.path.join(os.path.dirname(__file__), '../data/scans')
        if os.path.exists(scans_dir):
            for f in os.listdir(scans_dir):
                if f.endswith('.xml'):
                    files.append({
                        'name': f,
                        'path': os.path.join(scans_dir, f),
                        'type': 'nmap'
                    })
                    
        return files
        
    def _load_nessus_file(self) -> Optional[Dict[str, Any]]:
        """Load and validate Nessus file"""
        self.clear_screen()
        print(f"{Color.BOLD}üìÑ Load Nessus Scan{Color.RESET}")
        print("=" * 50)
        
        file_path = input("Enter path to Nessus file (or press Enter to browse): ").strip()
        
        if not file_path:
            # Browse for files
            files = self._discover_scan_files()
            nessus_files = [f for f in files if f['type'] == 'nessus']
            
            if not nessus_files:
                print(f"{Color.YELLOW.value}‚ö†Ô∏è  No Nessus files found{Color.RESET.value}")
                input("Press Enter to continue...")
                return None
                
            print(f"\nAvailable Nessus files:")
            for i, f in enumerate(nessus_files):
                print(f"  {i+1}. {f['name']}")
                
            try:
                choice = int(input(f"Select file (1-{len(nessus_files)}): ")) - 1
                if 0 <= choice < len(nessus_files):
                    file_path = nessus_files[choice]['path']
                else:
                    print("Invalid selection")
                    input("Press Enter to continue...")
                    return None
            except ValueError:
                print("Invalid input")
                input("Press Enter to continue...")
                return None
        
        # Validate file
        if not os.path.exists(file_path):
            print(f"{Color.RED.value}‚ùå File not found: {file_path}{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        if not file_path.endswith('.nessus'):
            print(f"{Color.RED.value}‚ùå Not a Nessus file: {file_path}{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        return {
            'type': 'nessus',
            'path': file_path,
            'name': os.path.basename(file_path)
        }
        
    def _run_nmap_scan(self) -> Optional[Dict[str, Any]]:
        """Run live Nmap scan"""
        self.clear_screen()
        print(f"{Color.BOLD}üåê Run Live Nmap Scan{Color.RESET}")
        print("=" * 50)
        
        # Get target
        default_target = self.config.get('target', {}).get('ip', '127.0.0.1')
        target = input(f"Target IP [{default_target}]: ").strip() or default_target
        
        if not target:
            print(f"{Color.RED.value}‚ùå Target IP required{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        # Scan options
        print(f"\nScan Options:")
        print("1. Quick Scan (top 1000 ports)")
        print("2. Full Scan (all 65535 ports)")
        print("3. Custom Scan")
        
        scan_type = input("Select scan type (1-3): ").strip()
        
        if scan_type == '1':
            nmap_args = "-sV -sC --top-ports 1000 -T4"
        elif scan_type == '2':
            nmap_args = "-sV -sC -p- -T4"
        elif scan_type == '3':
            nmap_args = input("Enter custom nmap arguments: ").strip()
        else:
            print("Invalid selection, using quick scan")
            nmap_args = "-sV -sC --top-ports 1000 -T4"
            
        # Confirm scan
        print(f"\n{Color.YELLOW.value}About to scan: {target}{Color.RESET.value}")
        print(f"Command: nmap {nmap_args} {target}")
        
        confirm = input("Proceed? (y/n): ").strip().lower()
        if confirm != 'y':
            return None
            
        # Run scan
        return self._execute_nmap_scan(target, nmap_args)
        
    def _execute_nmap_scan(self, target: str, nmap_args: str) -> Optional[Dict[str, Any]]:
        """Execute Nmap scan and return results"""
        try:
            from apfa_agent.core.nmap_scanner import NmapScanner
            
            print(f"\n{Color.CYAN.value}üîç Scanning {target}...{Color.RESET.value}")
            print("This may take several minutes...")
            
            # Create scanner
            scanner = NmapScanner(self.config)
            
            # Run scan with progress
            start_time = time.time()
            results = scanner.scan(target)
            elapsed = time.time() - start_time
            
            print(f"\n{Color.GREEN.value}‚úÖ Scan completed in {elapsed:.1f} seconds{Color.RESET.value}")
            
            # Save results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            scan_file = f"nmap_{target}_{timestamp}.xml"
            scan_path = os.path.join(os.path.dirname(__file__), '../data/scans', scan_file)
            
            os.makedirs(os.path.dirname(scan_path), exist_ok=True)
            
            # Convert results to vulnerability format
            vulnerabilities = self._nmap_to_vulnerabilities(results, target)
            
            with open(scan_path, 'w') as f:
                json.dump({
                    'target': target,
                    'timestamp': timestamp,
                    'scan_args': nmap_args,
                    'elapsed_time': elapsed,
                    'vulnerabilities': vulnerabilities
                }, f, indent=2)
                
            print(f"Results saved to: {scan_path}")
            
            return {
                'type': 'nmap',
                'path': scan_path,
                'name': scan_file,
                'target': target,
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Scan failed: {e}{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
    def _nmap_to_vulnerabilities(self, scan_results: Dict[str, Any], target: str) -> List[Dict[str, Any]]:
        """Convert Nmap results to vulnerability format"""
        vulnerabilities = []
        
        # Extract open ports and services
        if 'hosts' in scan_results:
            for host in scan_results['hosts']:
                if 'ports' in host:
                    for port_info in host['ports']:
                        if port_info.get('state') == 'open':
                            port_num = port_info.get('port', 0)
                            service = port_info.get('service', {})
                            service_name = service.get('name', 'unknown')
                            service_product = service.get('product', '')
                            service_version = service.get('version', '')
                            
                            # Create vulnerability record
                            vuln = {
                                'id': f'nmap_{target}_{port_num}',
                                'h': target,
                                'p': port_num,
                                's': 1,  # Low severity for open ports
                                'pn': f'{service_name} Service Detection',
                                'c': '',
                                'cvss': 0.0,
                                'd': f'Open port {port_num}/{service_name}. Product: {service_product} {service_version}',
                                'sol': 'Review if this service should be exposed',
                                'service': service_name,
                                'product': service_product,
                                'version': service_version
                            }
                            vulnerabilities.append(vuln)
                            
        return vulnerabilities
        
    def _browse_files(self, files: List[Dict[str, str]]) -> Optional[Dict[str, Any]]:
        """Browse and select from available files"""
        if not files:
            print(f"{Color.YELLOW.value}‚ö†Ô∏è  No scan files found{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        self.clear_screen()
        print(f"{Color.BOLD}üìÅ Available Scan Files{Color.RESET}")
        print("=" * 50)
        
        for i, f in enumerate(files):
            icon = "üìÑ" if f['type'] == 'nessus' else "üåê"
            print(f"{i+1}. {icon} {f['name']} ({f['type']})")
            
        try:
            choice = int(input(f"\nSelect file (1-{len(files)}): ")) - 1
            if 0 <= choice < len(files):
                selected_file = files[choice]
                
                # Load the file
                if selected_file['type'] == 'nessus':
                    return self._load_nessus_from_path(selected_file['path'])
                else:
                    return self._load_scan_from_path(selected_file['path'], selected_file['type'])
            else:
                print("Invalid selection")
                input("Press Enter to continue...")
                return None
                
        except ValueError:
            print("Invalid input")
            input("Press Enter to continue...")
            return None
            
    def _load_nessus_from_path(self, file_path: str) -> Dict[str, Any]:
        """Load Nessus file from specific path"""
        return {
            'type': 'nessus',
            'path': file_path,
            'name': os.path.basename(file_path)
        }
        
    def _load_scan_from_path(self, file_path: str, scan_type: str) -> Optional[Dict[str, Any]]:
        """Load scan file from specific path"""
        if scan_type == 'nmap' and file_path.endswith('.xml'):
            # Parse Nmap XML
            vulnerabilities = self._parse_nmap_xml(file_path)
            return {
                'type': 'nmap',
                'path': file_path,
                'name': os.path.basename(file_path),
                'vulnerabilities': vulnerabilities
            }
        elif scan_type == 'json':
            # Load JSON
            with open(file_path, 'r') as f:
                data = json.load(f)
                return {
                    'type': 'json',
                    'path': file_path,
                    'name': os.path.basename(file_path),
                    'vulnerabilities': data.get('vulnerabilities', [])
                }
                
        return None
        
    def _parse_nmap_xml(self, file_path: str) -> List[Dict[str, Any]]:
        """Parse Nmap XML file to extract vulnerabilities"""
        import xml.etree.ElementTree as ET
        
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            vulnerabilities = []
            for host in root.findall('.//host'):
                addr_elem = host.find('.//address[@addrtype="ipv4"]')
                if addr_elem is None:
                    continue
                ip_addr = addr_elem.get('addr', 'unknown')
                
                for port_elem in host.findall('.//port'):
                    state = port_elem.find('state')
                    if state is not None and state.get('state') == 'open':
                        port_num = int(port_elem.get('portid', 0))
                        service = port_elem.find('service')
                        service_name = service.get('name', 'unknown') if service is not None else 'unknown'
                        service_product = service.get('product', '') if service is not None else ''
                        service_version = service.get('version', '') if service is not None else ''
                        
                        vuln = {
                            'id': f'nmap_{ip_addr}_{port_num}',
                            'h': ip_addr,
                            'p': port_num,
                            's': 1,
                            'pn': f'{service_name} Service Detection',
                            'c': '',
                            'cvss': 0.0,
                            'd': f'Open port: {port_num}/{service_name}. Product: {service_product} {service_version}',
                            'sol': 'Review if this service should be exposed'
                        }
                        vulnerabilities.append(vuln)
                        
            return vulnerabilities
            
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Error parsing Nmap XML: {e}{Color.RESET.value}")
            return []
            
    def _show_recent_files(self) -> Optional[Dict[str, Any]]:
        """Show recently used files"""
        # TODO: Implement recent files functionality
        print(f"{Color.YELLOW.value}üîÑ Recent files feature coming soon{Color.RESET.value}")
        input("Press Enter to continue...")
        return None
        
    def _process_scan_data(self, scan_data: Dict[str, Any]) -> Optional[List[Dict[str, Any]]]:
        """Step 2: Process and classify scan data"""
        self.clear_screen()
        print(f"{Color.BOLD}üîÑ Processing Scan Data{Color.RESET}")
        print("=" * 50)
        
        print(f"Processing: {scan_data['name']}")
        
        # Parse based on type
        if scan_data['type'] == 'nessus':
            vulnerabilities = self._process_nessus(scan_data['path'])
        elif scan_data['type'] == 'nmap':
            if 'vulnerabilities' in scan_data:
                vulnerabilities = scan_data['vulnerabilities']
            else:
                vulnerabilities = self._parse_nmap_xml(scan_data['path'])
        elif scan_data['type'] == 'json':
            vulnerabilities = self._process_json(scan_data['path'])
        else:
            print(f"{Color.RED.value}‚ùå Unsupported scan type: {scan_data['type']}{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        if not vulnerabilities:
            print(f"{Color.YELLOW.value}‚ö†Ô∏è  No vulnerabilities found{Color.RESET.value}")
            input("Press Enter to continue...")
            return None
            
        print(f"Found {len(vulnerabilities)} vulnerabilities")
        
        # Classify vulnerabilities
        print(f"\n{Color.CYAN.value}üß† Classifying vulnerabilities...{Color.RESET.value}")
        classified_vulns = self._classify_vulnerabilities(vulnerabilities)
        
        print(f"{Color.GREEN.value}‚úÖ Processing complete{Color.RESET.value}")
        input("Press Enter to continue...")
        
        return classified_vulns
        
    def _process_nessus(self, file_path: str) -> List[Dict[str, Any]]:
        """Process Nessus file"""
        try:
            from parser.nessus_to_llm import VulnProcessor
            
            processor = VulnProcessor(file_path)
            vulns = processor.get_for_llm(fields=["id", "pn", "d", "c", "cvss", "s", "p", "h", "plugin_name", "description", "sol"])
            return vulns
            
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Error processing Nessus file: {e}{Color.RESET.value}")
            return []
            
    def _process_json(self, file_path: str) -> List[Dict[str, Any]]:
        """Process JSON file"""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                
            if isinstance(data, list):
                return data
            elif isinstance(data, dict) and 'vulnerabilities' in data:
                return data['vulnerabilities']
            elif isinstance(data, dict):
                return [data]
            else:
                return []
                
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Error processing JSON file: {e}{Color.RESET.value}")
            return []
            
    def _classify_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Classify vulnerabilities with intelligence enrichment"""
        try:
            from classifier.vulnerability_classifier import VulnerabilityClassifier
            
            classifier = VulnerabilityClassifier(enable_rag=False)
            
            # Show progress
            print("Applying intelligence enrichment...")
            self.progress_bar.show_progress(0, 100, "Classifying")
            
            results = classifier.classify_batch(vulnerabilities)
            
            self.progress_bar.show_progress(100, 100, "Classifying")
            
            # Extract vulnerabilities from results
            classified_vulns = []
            for result in results:
                if isinstance(result, dict) and 'original' in result:
                    vuln = result['original']
                    if 'classification' in result:
                        vuln['_classification'] = result['classification']
                    classified_vulns.append(vuln)
                else:
                    classified_vulns.append(result)
                    
            print(f"\nClassified {len(classified_vulns)} vulnerabilities")
            return classified_vulns
            
        except Exception as e:
            print(f"{Color.YELLOW.value}‚ö†Ô∏è  Classification failed, using raw data: {e}{Color.RESET.value}")
            return vulnerabilities
            
    def _select_targets(self, vulnerabilities: List[Dict[str, Any]]) -> Optional[List[Dict[str, Any]]]:
        """Step 3: Interactive target selection"""
        return self.selection_grid.show_vulnerability_grid(vulnerabilities)
        
    def _execute_assessment(self, selected_targets: List[Dict[str, Any]]) -> bool:
        """Step 4: Execute vulnerability assessment"""
        self.clear_screen()
        print(f"{Color.BOLD}üöÄ Starting Vulnerability Assessment{Color.RESET}")
        print("=" * 50)
        
        # Show scope summary
        critical = len([t for t in selected_targets if t.get('s', 0) == 4])
        high = len([t for t in selected_targets if t.get('s', 0) == 3])
        medium = len([t for t in selected_targets if t.get('s', 0) == 2])
        low = len([t for t in selected_targets if t.get('s', 0) == 1])
        
        print(f"{Color.BOLD}üìä Assessment Scope:{Color.RESET}")
        print(f"   Total targets: {len(selected_targets)}")
        print(f"   üî¥ Critical: {critical}")
        print(f"   üü† High: {high}")
        print(f"   üü° Medium: {medium}")
        print(f"   üü¢ Low: {low}")
        
        # Extract unique hosts and ports
        hosts = sorted(list(set(t.get('h', '') for t in selected_targets if t.get('h', ''))))
        ports = sorted(list(set(int(t.get('p', 0)) for t in selected_targets if t.get('p', 0))))
        
        print(f"\n{Color.BOLD}üéØ Targets:{Color.RESET}")
        print(f"   Hosts: {', '.join(hosts)}")
        print(f"   Ports: {', '.join(map(str, ports))}")
        
        # Save scope
        scope_data = {
            'targets': selected_targets,
            'hosts': hosts,
            'ports': ports,
            'created_at': datetime.now().isoformat()
        }
        
        scope_path = os.path.join(os.path.dirname(__file__), '../data/temp/scope.json')
        os.makedirs(os.path.dirname(scope_path), exist_ok=True)
        
        with open(scope_path, 'w') as f:
            json.dump(scope_data, f, indent=2)
            
        print(f"\nScope saved to: {scope_path}")
        
        # Confirm execution
        print(f"\n{Color.YELLOW.value}‚ö†Ô∏è  This will launch the intelligent pentesting agent{Color.RESET.value}")
        confirm = input("Proceed with assessment? (y/n): ").strip().lower()
        
        if confirm != 'y':
            return False
            
        # Launch agent
        return self._launch_assessment_agent(scope_path)
        
    def _launch_assessment_agent(self, scope_path: str) -> bool:
        """Launch the assessment agent with scope"""
        try:
            from apfa_agent.agent_mode import SmartTriageAgent
            
            print(f"\n{Color.CYAN.value}ü§ñ Launching Smart Triage Agent...{Color.RESET.value}")
            
            # Create agent
            agent = SmartTriageAgent(config_path=self._get_config_path(), config=self.config)
            
            # Run assessment
            agent.run(classified_json_path=scope_path, nmap_results=None)
            
            print(f"{Color.GREEN.value}‚úÖ Assessment completed successfully{Color.RESET.value}")
            print(f"Results saved to: data/agent_results/")
            
            return True
            
        except Exception as e:
            print(f"{Color.RED.value}‚ùå Agent execution failed: {e}{Color.RESET.value}")
            import traceback
            traceback.print_exc()
            return False
            
    def _get_config_path(self) -> str:
        """Get path to agent configuration"""
        return os.path.join(os.path.dirname(__file__), '../apfa_agent/config/agent_config.yaml')